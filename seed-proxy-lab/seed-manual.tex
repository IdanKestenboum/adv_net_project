    \documentclass[12pt]{article}
    \usepackage[a4paper, margin=1in]{geometry}
    \usepackage{enumitem}
    \usepackage{hyperref}
    \usepackage{listings}
    \usepackage{xcolor}
    \usepackage{graphicx}
    \usepackage{tikz}
    \usepackage{amsmath}
    \usepackage{amssymb}
    \usepackage{booktabs}
    \usepackage{multirow}
    \usepackage{float}
    \usepackage{caption}
    \usepackage{subcaption}

    % Code listing settings
    \lstset{
        basicstyle=\ttfamily\footnotesize,
        breaklines=true,
        frame=single,
        numbers=left,
        numberstyle=\tiny,
        keywordstyle=\color{blue},
        commentstyle=\color{green!60!black},
        stringstyle=\color{red},
        backgroundcolor=\color{gray!10},
        showstringspaces=false,
        tabsize=4
    }

    % TikZ settings
    \usetikzlibrary{shapes,arrows,positioning,fit}

    \title{SEED Labs â€“ Slow HTTP/TCP DDoS Attack and Mitigation Lab}
    \author{Idan Kestenboum \and Shachar Gabbay}
    \date{\today}

    \begin{document}

    \maketitle

    \begin{abstract}
    This lab demonstrates slow HTTP/TCP DDoS attacks and their mitigation using HAProxy. Students will learn about slow POST attacks, understand how it can exhaust server resources, and implement protection mechanisms using path-based bypass rules and IP-based throttling with stick tables. This version requires students to complete two simple implementation tasks to demonstrate their understanding of the key concepts.
    \end{abstract}

    \tableofcontents
    \newpage

    \section{Lab Overview}

    \subsection{Learning Objectives}
    By completing this lab, students will understand how slow HTTP/TCP (slow POST) attacks exhaust server resources and degrade user experience, and how a reverse proxy (HAProxy) can mitigate such attacks. Students will configure a minimal protection using stick tables and ACLs, test path-based bypass versus protected paths, and evaluate the outcome from both the attacker's and the user's perspectives. Two short implementation tasks solidify these concepts.

    \subsection{Prerequisites}
    \begin{itemize}
        \item Basic understanding of HTTP protocol and TCP connections
        \item Familiarity with Docker and containerization
        \item Knowledge of networking concepts (IP addresses, ports, connections)
        \item Basic Linux command-line experience
        \item Basic Python programming knowledge
    \end{itemize}

    \subsection{Lab Environment}
    The lab runs entirely in Docker. An \texttt{nginx-server} provides the backend service (exposed on host port 8080). An \texttt{haproxy} container fronts the backend on port 8081 and will host our protection rules. A dedicated \texttt{attacker} container runs the slow POST script, while a \texttt{user} container issues legitimate requests to observe service health. All containers share a user-defined Docker network and resolve each other by name.

    \section{Background Theory}

    \subsection{Slow HTTP/TCP DDoS Attacks}

    Slow HTTP/TCP attacks are application-layer DDoS attacks that exploit the way web servers handle HTTP connections. Unlike traditional DDoS attacks that flood servers with high-volume traffic, slow attacks use low-bandwidth connections that remain open for extended periods.

    \subsubsection{Slow POST Attack}
    The slow POST attack:
    \begin{enumerate}
        \item Sends a POST request with a large Content-Length header
        \item Establishes the connection and sends headers
        \item Sends the request body very slowly (e.g., 1 byte per second)
        \item Keeps the connection open until the entire body is sent
    \end{enumerate}

    \subsection{HAProxy Protection Mechanisms}

    \subsubsection{What is HAProxy?}
    HAProxy (High Availability Proxy) is a free, very fast and reliable solution offering high availability, load balancing, and proxying for TCP and HTTP-based applications. It is particularly suited for web sites crawling under very high load while needing persistence or Layer 7 processing. HAProxy runs on event-driven, non-blocking engine, making it very efficient and suitable for high-traffic web sites.

    Key features of HAProxy include:
    \begin{itemize}
        \item \textbf{Load Balancing}: Distributes incoming requests across multiple backend servers
        \item \textbf{Rate Limiting}: Controls request rates to prevent abuse
        \item \textbf{Stick Tables}: Tracks client behavior for advanced traffic management
        \item \textbf{ACLs}: Access Control Lists for making routing decisions based on various criteria
    \end{itemize}

    \subsubsection{Stick Tables}
    Stick tables are HAProxy's mechanism for tracking client behavior across multiple connections. They act as in-memory databases that store information about clients (typically identified by IP address) and their associated metrics.

    \textbf{Key Concepts:}
    \begin{itemize}
        \item \textbf{Type}: IP-based tracking (can also track other identifiers like user-agent, cookie, etc.)
        \item \textbf{Size}: Configurable table size (e.g., 100k entries) - when full, oldest entries are evicted
    \end{itemize}

    \textbf{Example Configuration:}
    \begin{lstlisting}[language=bash]
    # Define a stick table for tracking abusive IPs
    backend abuse_tracker
        stick-table type ip size 100k expire 10m store conn_rate(10s)
    \end{lstlisting}

    \subsubsection{Access Control Lists (ACLs)}
    Access Control Lists (ACLs) are HAProxy's primary mechanism for making routing decisions based on various conditions. ACLs evaluate to true or false and can be combined using logical operators.

    \textbf{Common ACL Types:}
    \begin{itemize}
        \item \textbf{Path-based ACLs}: Match URL paths (e.g., \texttt{path\_beg /bypass})
        \item \textbf{IP-based ACLs}: Match source IP addresses (e.g., \texttt{src 192.168.1.0/24})

    \end{itemize}

    \subsubsection{Integration of Stick Tables and ACLs}
    The power of HAProxy's protection mechanisms comes from combining stick tables and ACLs:

    \begin{enumerate}
        \item \textbf{Tracking}: Stick tables track client behavior (e.g., connection rates)
        \item \textbf{Evaluation}: ACLs evaluate conditions based on stick table data
        \item \textbf{Action}: Routing decisions are made based on ACL evaluation results
    \end{enumerate}

    This integration allows HAProxy to:
    \begin{itemize}
        \item Dynamically identify abusive clients based on their behavior
        \item Route traffic to different backends based on client reputation
        \item Maintain service quality for legitimate users while handling attacks
        \item Automatically adapt to changing attack patterns
    \end{itemize}

    \section{Lab Setup}

    \subsection{Environment Preparation}

    \subsubsection{Step 1: Clone and Navigate}
    \begin{lstlisting}[language=bash]
    # Navigate to the lab directory
    cd seed-proxy-lab

    # Verify the structure
    ls -la
    \end{lstlisting}

    \subsubsection{Step 2: Build and Start Containers}
    \begin{lstlisting}[language=bash]
    # Build and start all services
    docker-compose up -d --build

    # Verify all containers are running
    docker-compose ps
    \end{lstlisting}

    \subsubsection{Step 3: Verify Services}
    \begin{lstlisting}[language=bash]
    # Check if nginx is accessible directly
    curl http://localhost:8080

    # Check if HAProxy is accessible
    curl http://localhost:8081
    \end{lstlisting}

    \subsection{Network Topology}

    \begin{figure}[H]
    \centering
    \begin{tikzpicture}[
        node distance=3.2cm,
        box/.style={rectangle,draw,minimum width=3.2cm,minimum height=1.4cm,align=center},
        arrow/.style={->,thick},
        network/.style={rectangle,draw,dashed,minimum width=5cm,minimum height=3cm,align=center}
    ]
        \node[box] (user) {User Container\\172.17.0.x};
        \node[box,right=5cm of user] (attacker) {Attacker Container\\172.17.0.x};
        
        \node[network,below=3.2cm of user] (network) {Docker Network\\ddos-net};
        
        \node[box,below=3.2cm of network] (haproxy) {HAProxy\\Port 8081};
        \node[box,below=3.2cm of haproxy] (nginx) {Nginx Server\\Port 8080};
        
        \draw[arrow] (user) -- (network);
        \draw[arrow] (attacker) -- (network);
        \draw[arrow] (network) -- (haproxy);
        \draw[arrow] (haproxy) -- (nginx);
        
        \draw[arrow] (user) to[bend left=50] node[above,sloped] {Direct Access} (nginx);
    \end{tikzpicture}
    \caption{Lab Network Topology}
    \label{fig:topology}
    \end{figure}

    \section{Implementation Tasks}

    \subsection{Task 1: HAProxy Configuration Implementation}

    In this task, you will implement two key components of the HAProxy configuration. Open the file \texttt{seed-proxy-lab/haproxy/haproxy.cfg} and complete the following tasks:

    \subsubsection{Task 1.1: Define Stick Table}
    Complete the stick table configuration in the \texttt{abuse\_tracker} backend:

    \begin{lstlisting}[language=bash, caption=HAProxy Configuration - Task 1.1]
    # TODO: Task 1 - Define stick table for tracking abusive IPs
    # Complete the stick table configuration below:
    # - Type should be 'ip' for IP-based tracking
    # - Size should be 100k entries
    # - Expire after 10 minutes
    # - Store connection rate over 10 seconds
    backend abuse_tracker
        # ** FILL HERE **
        # stick-table type ip size 100k expire 10m store conn_rate(10s)
    \end{lstlisting}

    \textbf{Requirements:}
    \begin{itemize}
        \item Type: \texttt{ip} for IP-based tracking
        \item Size: \texttt{100k} entries
        \item Expiration: \texttt{10m} (10 minutes)
        \item Storage: \texttt{conn\_rate(10s)} (connection rate over 10 seconds)
    \end{itemize}

    \subsubsection{Task 1.2: Define ACL for Abusive IPs}
    Create ACL to identify abusive IPs:

    \begin{lstlisting}[language=bash, caption=HAProxy Configuration - Task 1.2]
    # TODO: Task 2 - Define ACL for abusive IPs
    # Create an ACL that identifies IPs with more than 20 connections in 10 seconds
    # ** FILL HERE **
    # acl abusive_ip src_conn_rate(abuse_tracker) gt 20
    \end{lstlisting}

    \textbf{Requirements:}
    \begin{itemize}
        \item Create ACL named \texttt{abusive\_ip}
        \item Check if connection rate from stick table is greater than 20
        \item Use \texttt{src\_conn\_rate(abuse\_tracker) gt 20}
    \end{itemize}

    \subsection{Task 2: Attack Script Implementation}

    In this task, you will implement two key components of the slow POST attack script. Open the file \texttt{seed-proxy-lab/attacker/slow\_post\_threads.py} and complete the following tasks:

    \subsubsection{Task 2.1: Implement Target Selection}
    Complete the target host and port selection logic:

    \begin{lstlisting}[language=python, caption=Attack Script - Task 2.1]
    # TODO: Task 1 - Implement target host and port selection
    # Complete the logic to set the correct host and port based on the target argument
    # - If target is "proxy", use "haproxy" as host and 8081 as port
    # - If target is "direct", use "nginx-server" as host and 80 as port
    # ** FILL HERE **
    if target == "proxy":
        # ** FILL HERE **
        pass
    else:
        # ** FILL HERE **
        pass
    \end{lstlisting}

    \textbf{Requirements:}
    \begin{itemize}
        \item If \texttt{target} is \texttt{"proxy"}: set \texttt{host = "haproxy"} and \texttt{port = 8081}
        \item If \texttt{target} is \texttt{"direct"}: set \texttt{host = "nginx-server"} and \texttt{port = 80}
    \end{itemize}

    \subsubsection{Task 2.2: Implement Slow Data Transmission}
    Complete the slow data transmission logic:

    \begin{lstlisting}[language=python, caption=Attack Script - Task 2.2]
    # TODO: Task 2 - Implement slow data transmission
    # Send data slowly to keep the connection open
    # Send one byte at a time with a 0.05 second delay between sends
    # ** FILL HERE **
    while True:
        # ** FILL HERE **
        pass
    \end{lstlisting}

    \textbf{Requirements:}
    \begin{itemize}
        \item Send one byte (\texttt{b"A"}) at a time
        \item Sleep for 0.05 seconds between sends
        \item Continue indefinitely to keep connection open
    \end{itemize}

    \section{Phase 1: Direct DDoS Attack}

    \subsection{Objective}
    Demonstrate how slow HTTP/TCP attacks can overwhelm a backend server when no protection is in place.

    \subsection{Task 1: Baseline Performance Test}

    \subsubsection{Step 1: Access User Container}
    \begin{lstlisting}[language=bash]
    # Access the user container
    docker exec -it user sh
    \end{lstlisting}

    \subsubsection{Step 2: Measure Normal Response Time}
    \begin{lstlisting}[language=bash]
    # Test normal response time using container name
    time curl -s http://nginx-server:80 > /dev/null
    \end{lstlisting}

    \subsubsection{Step 3: Monitor Server Resources}
    \begin{lstlisting}[language=bash]
    # In another terminal, monitor nginx server
    docker exec -it nginx-server bash

    # Monitor system resources
    htop
    \end{lstlisting}

    \subsection{Task 2: Execute Slow POST Threads Attack (Direct)}

    \subsubsection{Step 1: Access Attacker Container}
    \begin{lstlisting}[language=bash]
    # Access the attacker container
    docker exec -it attacker bash
    \end{lstlisting}

    \subsubsection{Step 2: Launch Direct Attack}
    \begin{lstlisting}[language=bash]
    # Navigate to the attack directory
    cd /app

    # Run slow POST threads attack directly against nginx-server
    python3 slow_post_threads.py direct protected
    \end{lstlisting}

    \subsubsection{Step 3: Monitor Impact}
    \begin{lstlisting}[language=bash]
    # In the nginx container, monitor connections
    watch -n 1 "netstat -an | grep :80 | wc -l"
    \end{lstlisting}

    \subsubsection{Step 4: Test Legitimate User Access}
    \begin{lstlisting}[language=bash]
    # In the user container, test access during attack
    time curl -s http://nginx-server:80 > /dev/null
    \end{lstlisting}

    \subsection{Expected Results}
    \begin{itemize}
        \item Server response times increase significantly
        \item Connection count rises rapidly
        \item Legitimate users experience timeouts
        \item Server may become unresponsive
    \end{itemize}

    \section{HAProxy Protection Walkthrough}

    \subsection{Objective}
    Understand what the HAProxy rules do and how to test them. You only need to complete two short TODOs earlier; this section focuses on observing behavior, and assumes you already filled two TODOs earlier (stick table and abusive ACL). No additional edits are needed here; just ensure your configuration is loaded and then run the tests.

    


    \subsection{Test 1: Bypass Path (Attack Succeeds)}

    \subsubsection{Step 1: Access User Container}
    \begin{lstlisting}[language=bash]
    # Access the user container
    docker exec -it user sh
    \end{lstlisting}

    \subsubsection{Step 2: Test Bypass Path}
    \begin{lstlisting}[language=bash]
    # Test bypass path using container name
    curl -v http://haproxy:8081/bypass/test
    \end{lstlisting}

    \subsubsection{Step 3: Launch Attack Using Bypass Path}
    \begin{lstlisting}[language=bash]
    # In the attacker container, launch attack using bypass path
    python3 slow_post_threads.py proxy bypass
    \end{lstlisting}

    \subsubsection{Step 4: Test Legitimate User Access During Bypass Attack}
    \begin{lstlisting}[language=bash]
    # In the user container, test access during bypass attack
    time curl -s http://haproxy:8081/ > /dev/null
    \end{lstlisting}
    \subsection{Test 2: Protected Path (Mitigation Holds)}

    \subsubsection{Step 1: Launch Attack Using Protected Path}
    \begin{lstlisting}[language=bash]
    # In the attacker container, launch attack using protected path
    python3 slow_post_threads.py proxy protected
    \end{lstlisting}


    # Check connection distribution
    docker exec -it haproxy haproxy -c -f /usr/local/etc/haproxy/haproxy.cfg
    \end{lstlisting}

    \subsubsection{Step 2: Test Legitimate User Access During Protected Attack}
    \begin{lstlisting}[language=bash]
    # In the user container, test access during protected attack
    time curl -s http://haproxy:8081/ > /dev/null
    \end{lstlisting}

    \subsection{Attack scenarios Overview}

    After completing the direct attack against \texttt{nginx-server}, move to HAProxy and run the same attack first through the bypass path and then through the protected path. The goal is to contrast unprotected forwarding with policy-driven mitigation and verify that legitimate user traffic remains healthy only in the protected case.

    - \textbf{Direct to backend}: The slow POST flood ties up server resources; user requests typically stall or time out.
    - \textbf{Via HAProxy bypass (/bypass)}: Traffic is forwarded without protection; the backend still degrades similarly to the direct case.
    - \textbf{Via HAProxy protected (/)}: With your stick-table + ACL in place, abusive sources exceed the connection-rate threshold and are isolated; user requests to \texttt{http://haproxy:8081/} should remain responsive.

    \section{Real-World Proxy Load Balancing Applications}

    \subsection{Introduction}
    The HAProxy-based protection mechanisms demonstrated in this lab are widely used in real-world production environments. Understanding how proxies and load balancers work in practice helps students appreciate the practical applications of the concepts learned.

    \subsection{Common Use Cases}

    In production, proxies and load balancers most commonly power three themes. First, web application load balancing spreads requests across multiple backends, performs health checks to remove unhealthy nodes, and can handle concerns like session persistence and TLS termination at the edge. Second, DDoS protection and mitigation employ techniques such as rate limiting and traffic filtering; they also benefit from geographic distribution and traffic shaping to prioritize legitimate flows. Third, high availability and failover improve resilience through activeâ€“passive or activeâ€“active topologies, automatic failover, and distribution across multiple data centers.

    \subsection{Conclusion}
    The concepts learned in this lab provide a foundation for understanding real-world proxy and load balancing implementations. The HAProxy configuration and protection mechanisms demonstrated here are directly applicable to production environments, where they help ensure high availability, security, and performance for web applications and services.


    \section{Submission Requirements}

    \subsection{Required Deliverables}
    \begin{itemize}
        \item Completed \texttt{haproxy.cfg} file with all TODO tasks implemented
        \item Completed \texttt{slow\_post\_threads.py} file with all TODO tasks implemented
        \item Screenshots showing successful compilation and testing
        \item Brief report explaining your implementation choices
    \end{itemize}

    \subsection{Submission Format}
    Submit the following files:
    \begin{enumerate}
        \item \texttt{haproxy.cfg} - Your completed HAProxy configuration
        \item \texttt{slow\_post\_threads.py} - Your completed attack script
        \item \texttt{implementation\_report.pdf} - Brief report (1-2 pages) explaining your implementation
        \item Screenshots of successful testing (as separate image files)
    \end{enumerate}


    \subsection{Conclusion}
    The concepts learned in this lab provide a foundation for understanding real-world proxy and load balancing implementations. The HAProxy configuration and protection mechanisms demonstrated here are directly applicable to production environments, where they help ensure high availability, security, and performance for web applications and services.


    \section{References}

    \begin{enumerate}
        \item HAProxy Documentation: \url{https://www.haproxy.org/download/2.6/doc/intro.txt}
        \item SEED Labs: \url{https://seedsecuritylabs.org}
        \item Slowloris Attack: \url{https://en.wikipedia.org/wiki/Slowloris_(computer_security)}
        \item DDoS Protection Strategies: \url{https://www.cloudflare.com/learning/ddos/}
    \end{enumerate}

    \end{document}
